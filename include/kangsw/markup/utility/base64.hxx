#pragma once
#include <array>
#include <string_view>

namespace kangsw::base64 {

inline size_t encoded_size(size_t binary_len) { return (binary_len + 2) / 3 * 4; }
inline size_t decoded_size(size_t string_len) { return (string_len + 3) / 4 * 3; }

constexpr char _table_encode[65] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
constexpr char _padchar          = '=';

constexpr uint8_t _table_decode[256] = {
  // clang-format off
    0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 
    0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 
    0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x3e, 0xcc, 0xcc, 0xcc, 0x3f, 
    0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0xcc, 0xcc, 0xcc, 0x00, 0xcc, 0xcc, 
    0xcc, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 
    0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 
    0xcc, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 
    0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 
    0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 
    0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 
    0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 
    0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 
    0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 
    0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 
    0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 
    0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc,
  // clang-format on
};

constexpr bool is_valid_b64_char(char ch) {
    return _table_decode[ch] != 0xcc;
}

inline void _encode_blk(char* o, void const* i) {
    auto ch = (uint8_t*)i;
    o[0]    = _table_encode[ch[0] >> 2];
    o[1]    = _table_encode[((ch[0] & 0x03) << 4) | (ch[1] >> (8 - 4))];
    o[2]    = _table_encode[((ch[1] & 0x0f) << 2) | (ch[2] >> (8 - 2))];
    o[3]    = _table_encode[ch[2] & 0x3f];
}

template <typename OutIt_>
void encode(void const* data, size_t len, OutIt_&& o) {
    for (; len >= 3; len -= 3, data = (void*)(intptr_t(data) + 3)) {
        char oblk[4];
        _encode_blk(oblk, data);

        o = oblk[0];
        o = oblk[1];
        o = oblk[2];
        o = oblk[3];
    }

    if (len) {
        char in[3] = {};
        char oblk[4];
        for (size_t i = 0; i < len; ++i) { in[i] = *((char*)data + i); }

        _encode_blk(oblk, in);
        int n_pad = 3 - (int)len;
        int n_ch  = 4 - n_pad;

        for (int i = 0; i < n_ch; ++i) { o = oblk[i]; }
        for (int i = 0; i < n_pad; ++i) { o = _padchar; }
    }
}

template <typename InIt_, typename OutIt_>
bool decode(InIt_ start, InIt_ const end, OutIt_ o) {
    // TODO: 입력 이터레이터 타입인 InIt_를 항상 random_access_iterator로 가정하여 최적화하는 로직 추가; if constexpr로 이터레이터 검사해서 루틴 분리. 지금 로직도 필요는 함 ... (스트림 입력 등 읽어오기 위해)
    using ivalue_type = typename std::iterator_traits<InIt_>::value_type;
    using ovalue_type = typename OutIt_::container_type::value_type;
    static_assert(sizeof(ivalue_type) == 1);
    static_assert(sizeof(ovalue_type) == 1);
    static_assert(std::is_trivial_v<ovalue_type>);

    for (auto it = start; it != end;) {
        char iblk[4] = {};
        int64_t oblk = 0;
        int pad_pos  = 0;

        for (; pad_pos < 4 && it != end; ++pad_pos, ++it) { iblk[pad_pos] = *it; }
        for (pad_pos = 0; pad_pos < 4 && iblk[pad_pos] != '='; ++pad_pos) {}
        if (pad_pos < 2) { return false; }

        for (int i = 0; i < pad_pos; ++i) {
            auto bitval = _table_decode[iblk[i]];
            if (bitval == 0xcc) { return false; }
            oblk |= bitval << (3 - i) * 6;
        }

        auto& chset = reinterpret_cast<std::array<const char, 3>&>(oblk);
        int n_bin   = (pad_pos == 4) ? 3 : (pad_pos == 3) ? 2 : 1;

        for (int i = 0; i < n_bin; ++i) { o = static_cast<ovalue_type>(chset[2 - i]); }
    }

    return true;
}

} // namespace kangsw::base64
